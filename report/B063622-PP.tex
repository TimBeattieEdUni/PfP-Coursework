%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MSc HPC
% Performance Programming
% Coursework
% Exam no. B063622
%
% Report.
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages.
%
\documentclass[11pt, oneside]{article}   % use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                    % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
\usepackage[parfill]{parskip}            % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}                    % Use pdf, png, jpg, or eps§ with pdflatex; use eps in DVI mode
                                         % TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{epstopdf}
\usepackage{amssymb}
\usepackage{listings}


% load .eps files created by GnuPlot for epstopdf to convert to .pdf
\DeclareGraphicsExtensions{.eps}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Components.
\title{Performance Programming \\ Coursework}
\author{B063622}
\date{\today}


%
% The following defines an environment for including source with syntax hilighting.
% (Copied from stackoverflow.com/questions/3175105/how-to-insert-code-%into-a-latex-doc) 
% Could be useful if we want to include source code in the report. 
%
% To use a different language, overwrite the language paramter in the code. I.e. write: 
%	\lstset{language=bash}
% before the beginning of the listing. 

% Then enter your code: 
%	\begin{lstlisting}
%		source code here ...
%	\end{lstlisting}
%

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=c++,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=false,
breakatwhitespace=true,   
tabsize=3
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The document itself.
%
\begin{document}

\pagenumbering{gobble}   % No page number on title page.
\maketitle

\newpage

\pagenumbering{roman}   % Preamble pages numbered in Roman numerals.
\tableofcontents

\newpage

\pagenumbering{arabic}  % Body of report numbered in Arabic.

\section{Introduction}
The following report describes the process of optimising a program which runs a molecular dynamics calculation.
The calculation models a number of particles which are subject to two forces: an inverse square attraction and a viscosity in the system.

A series of  modifications were made to the code in an attempt to optimise its performance, including several which degraded performance and which were discarded from the final code.
The modifications these are described, and an analysis of the effect of each modification on the code's performance is presented.

The code was provided in both C and Fortran; the C version was chosen for this exercise.

\section{First Steps}

\subsection{Examining the Code}
The first step was to study the code and its build process in order to gain an understanding of how the code worked and to identify potential modifications which might improve performance.
Several such possibilities were initially identified in the code and its make file:

\begin{itemize}
	\item Debug symbols enabled during compilation.
	\item Lack of compiler optimisation.
	\item Nested for loops with slowest-changing indices innermost.
	\item Loops which could be combined.
	\item Repeated calculations within loops.
	\item Loop-invariant values recalculated within loops.
	\item Branches within loops.
	\item Arrays sized as powers of 2.
	\item Related data in separate structures in memory.
	\item Multidimensional array indexing which could be converted to incrementing pointers.
\end{itemize}


\subsection{Recording Initial Performance}
An initial timing run was performed with the code and makefile unmodified.
The only change made to the provided files was to modify the Sun Grid Engine batch script {\em bench\_c.sge} to allocate 64 for cores for each run as shown in Figure~\ref{fig:batchsge}.
This was done in order to isolate timing runs from the effects of any other programs running on the same node on MORAR.
This setting was applied to all timing runs performed.

\begin{figure}
	\begin{lstlisting}
		#$ -l h\_rt=:20:
		#$ -pe mpi 64
		#$ -cwd
	\end{lstlisting}
	\caption{Modification to bench\_c.sge to allocate 64 cores for timing runs.}
	\label{fig:batchsge}
\end{figure}

The program performed five iterations of 100 steps with each step including the running count of collisions and with each set of 100 steps indicating the time taken for that set.  Times for the initial run are shown in Table~\ref{table:InitialRunTimes}.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{||l|c|l||}
			\hline
				{\bf Steps} & {\bf Time}\\
			\hline
				100  &  193.724736\\
				200  &  193.554321\\
				300  &  193.863500\\
				400  &  193.568124\\
				500  &  193.937730\\
			\hline
		\end{tabular}
	\end{center}
	\caption{Initial run times per 100 steps.}
	\label{table:InitialRunTimes}
\end{table}

The initial timing was very consistent, resulting in an average of 1.937 seconds per step, with times for each set of 100 steps varying by less than one percent.
For this reason, two runs of 100 steps each were considered sufficient for timing the first few modifications to the code.
It was anticipated that times might become less consistent when the program became more efficient as interruptions for I/O would affect the program more if it were keeping the CPU busy.
However, run times remained consistent to within approximately three percent throughout the work done, so the number of timing runs for each modification was not increased.

\subsection{Testing for Correctness}

The program printed the number of the current step and the running count of collisions to the standard output along with the time taken for each set of 100 steps.
The program also wrote the positions and velocities of each particle in the system to an output file after each set.
In order to consider the program to still be correct after a modification, both the particle data and the collision count had to be sufficiently accurate.  

Perfect accuracy was not required as the order of floating point arithmetic in the code might be altered.
A test tool was provided which compared the values in two output files and reported the maximum difference between corresponding values as well as any differences which were greater than a chosen minimum and which were therefore unacceptable.  

The tool had a bug: it failed to handle NaN values correctly.
The code which performed the comparison between values reported a difference of 0.0 between any floating point number and NaN.
A check for NaN values was added and the code was made to indicate that the difference between any valid value and NaN, or between two NaNs, was the largest available double-precision floating point value.
The modified code is shown in Figure~\ref{fig:NanTest}.

\begin{figure}
	\begin{lstlisting}
		double error(double v1, double v2)
		{
			//  check for invalid values and return a 
			//  value greater than any reasonable maximum delta
			if (isnan(v1) || isnan(v2))
			{
				return DBL_MAX;
			}

			double diff = fabs(v1 - v2);
			double sum = fabs(v1 + v2);
			if (sum != 0.0)
			{
				// normalise
				diff = diff / sum;
			}
			return diff;
		}
	\end{lstlisting}
	\caption{Checking for NaN values in diff tool.}
	\label{fig:NanTest}
\end{figure}



Initial runs unmodified - ( +  +  +  + ) / 5- very consistent timings at ~193.7 seconds to within 1/2 %
Data arrays large powers of 2.

Needed test to ensure correct mods - many mods.
Test program compared output within a given delta.
Didn't detect NaNs - had to add this - list code.
Needed collisions, empirically found they started at 162 (show output), so original output at 200 used as input.
Original program used to produce output 100 steps after 200th in input.

\section{Repeatable work process}
Modify code - small mods to isolate effects.
Run code.
64 cores - isolate.
Verify output
Measure performance - 2 runs, consistent.
Store output data, 2 morar outputs, and output from test for each modification.
Revert change if performance worse.

\section{Initial Steps}
First modification: remove -g flag.
Debug symbols - increase size of code and reduces performance.
107.066320s and 107.309783 
Consistent timing found using 64 cores, so 2 runs enough.
If runs varied, planned to increase number of runs.  Didn't vary.

Profiling run done, but unsurprisinbly all time spent in function evolve() as it contained all the loops.  Could have separated loops into functions, but obvious candidates (3-nested fors) so worked on them.

\section{Compiler optimisation flags}
Easy initial option: try adding compiler optimisation flags  O1-4 tried as well as–fast –Mipa=fast,inline  as recommended by th PGI Compiler User Guide. \cite{ref:PgiCC}  "If you want to get started quickly with optimization, a good set of options to use with any of the PGI compilers is -fast -Mipa=fast,inline."
O1: (only 1 run) 125.075299
O2: 127.319100
O3: 127.375565 127.023777
O4: 125.678674 125.906789
-fast -Mipa=fast,inline: 
Found that all optimisation flags actually increased run time.  Clear that compiler optimisation not a limiting factor in current code.
Left -fast -Mipa=fast,inline in place as expected to solve other problems - compiler optimisation flags generally make an improvement.

\section{Conclusion}
This section is the conclusion.

\begin{thebibliography}{100}

\bibitem{ref:PgiCC} {\em 2015 PGI Compiler User Guide} NVIDIA Corporation. pp 24-26.

\end{thebibliography}

\end{document}